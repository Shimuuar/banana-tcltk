module UI.Dispatch (
    Dispatch
  , newDispatch
  , setOutput
  , setPushInit
    -- * Events
  , registerEvent
  , pushInitEvent
  , pushMessage
    -- * Write data
  , writeRenderedTcl
  , writeTcl
  , writeTclParam
  ) where

import Control.Applicative
import Control.Monad.IO.Class

import Data.IORef
import qualified Data.Map as Map

import Reactive.Banana

import UI.TclTk.AST
import UI.Command
import UI.Log

import Text.PrettyPrint.ANSI.Leijen (red,text)


----------------------------------------------------------------
-- Dispatch
----------------------------------------------------------------

-- | Tcl commands and events generated by GUI are sent in serialized
--   form. So it's needed to send messages to all attached GUIs and
--   dispactch incoming GUI events to corresponding events.
--
--   GUI events are identified with unique automatically generated
--   prefix.
newtype Dispatch = Dispatch (IORef DispatchT)


data DispatchT = DispatchT
  { eventDispatch :: Map.Map String ([String] -> IO ())
  , outputMessage :: [String] -> IO ()
  , pushInit      :: IO ()
  }

-- | Create new dispatch
newDispatch :: IO Dispatch
newDispatch = do
  Dispatch <$> newIORef DispatchT { eventDispatch = Map.empty
                                  , outputMessage = const (return ())
                                  , pushInit      = return ()
                                  }

-- | Set init event.
setPushInit :: Dispatch -> IO () -> IO ()
setPushInit (Dispatch s) push = do
  atomicModifyIORef s (\x -> (x { pushInit = push },()))

-- | Set output function
setOutput :: Dispatch -> ([String] -> IO ()) -> IO ()
setOutput (Dispatch s) out = do
  atomicModifyIORef s (\x -> (x { outputMessage = out}, ()))


----------------------------------------------------------------
-- Events
----------------------------------------------------------------

-- | Fire initialization event
pushInitEvent :: Dispatch -> IO ()
pushInitEvent (Dispatch s) =
  pushInit =<< readIORef s


-- | Dispatch incoming event
pushMessage :: Dispatch -> [String] -> IO ()
pushMessage _ [] = return ()
pushMessage (Dispatch s) (key:msg) = do
  src <- readIORef s
  logDoc $ red $ text $ "Message: " ++ key ++ " : " ++ show msg
  case Map.lookup key $ eventDispatch src of
    Just f  -> f msg
    Nothing -> logDoc $ red $ text ">>> Unknown!"


-- | Register event in the dispatch table. This function is not meant
--   to be used directly. Use 'addTclEvent' instead.
registerEvent :: (Command a)
              => Dispatch       -- ^ Dispatch table
              -> String         -- ^ Unique event prefix.
              -> NetworkDescription t (AddHandler a)
registerEvent (Dispatch s) pref = do
  src  <- liftIO $ readIORef s
  (register, run) <- liftIO  newAddHandler
  let action str =
        case decode str of
          Just x  -> run x
          Nothing -> return ()
  liftIO $ writeIORef s $ src { eventDispatch = Map.insert pref action (eventDispatch src) }
  return register



----------------------------------------------------------------
-- Output
----------------------------------------------------------------

-- | Write raw code
writeRenderedTcl :: Dispatch -> [String] -> IO ()
writeRenderedTcl (Dispatch s) strs = do
  out <- outputMessage <$> readIORef s
  out strs

-- | Write tcl commands
writeTcl :: Dispatch -> [Tcl ()] -> IO ()
writeTcl s tcl
  = writeTclParam s tcl ()

-- | Write parametrized Tcl commands to output
writeTclParam :: Dispatch -> [Tcl p] -> p -> IO ()
writeTclParam s tcl p
  = writeRenderedTcl s $ flip renderTclParam p =<< tcl
